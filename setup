#!/usr/bin/env bash

set -euo pipefail

cd "$(dirname "$0")"

OPT_HELP=false
OPT_YES=false
OPT_USER=false
OPT_DEVELOP=false
OPT_INSTALL=true
OPT_REINSTALL=false
OPT_CLEAN=false
MAKE=${MAKE:-make -j}
PREFIX=${PREFIX:-/usr/local}
PYTHON=python3
PIP=pip3

export TMPDIR=${TMPDIR:-/tmp}
MY_TMPDIR="$TMPDIR/qip-media-tools-setup.$$.tmp"
cleanup() {
    [[ -n "$MY_TMPDIR" ]] && rm -Rf "$MY_TMPDIR/"
}
trap "cleanup ; exit 1" 1 2 9 14
trap "cleanup" 0
mkdir -p "$MY_TMPDIR"

OPTS_SHORT="h" ; OPTS_LONG="help"
OPTS_SHORT="${OPTS_SHORT}y" ; OPTS_LONG="${OPTS_LONG},yes"
OPTS_SHORT="${OPTS_SHORT}S" ; OPTS_LONG="${OPTS_LONG},system"
OPTS_SHORT="${OPTS_SHORT}U" ; OPTS_LONG="${OPTS_LONG},user"
OPTS_SHORT="${OPTS_SHORT}D" ; OPTS_LONG="${OPTS_LONG},develop"
OPTS_SHORT="${OPTS_SHORT}"  ; OPTS_LONG="${OPTS_LONG},prefix:"  # or $PREFIX
OPTS_SHORT="${OPTS_SHORT}i" ; OPTS_LONG="${OPTS_LONG},install"
OPTS_SHORT="${OPTS_SHORT}u" ; OPTS_LONG="${OPTS_LONG},uninstall"
OPTS_SHORT="${OPTS_SHORT}r" ; OPTS_LONG="${OPTS_LONG},reinstall"
OPTS_SHORT="${OPTS_SHORT}c" ; OPTS_LONG="${OPTS_LONG},clean,no-clean"
rc=0 ; getopt -T > /dev/null 2>&1 || rc=$?
if [[ "$rc" = 4 ]] ; then
    # GNU getopt
    TEMP=`POSIXLY_CORRECT=1 getopt --long $OPTS_LONG --options $OPTS_SHORT --name "$0" -- --system "$@"`
else
    # BSD getopt
    TEMP=`POSIXLY_CORRECT=1 getopt $OPTS_SHORT -S "$@"`
fi
eval set -- "$TEMP"

while true ; do
    case "$1" in

        -h|--help) OPT_HELP=true ; shift ;;
        -y|--yes)  OPT_YES=true  ; shift ;;

        -i|--install)   OPT_INSTALL=true                      ; shift ;;
        -u|--uninstall) OPT_INSTALL=false                     ; shift ;;
        -r|--reinstall) OPT_INSTALL=true  OPT_REINSTALL=true  ; shift ;;

        -S|--system)  PREFIX=/usr/local ; OPT_USER=false ; shift 1 ;;
        -U|--user)    PREFIX=~/.local   ; OPT_USER=true  ; shift 1 ;;
        -D|--develop) PREFIX=~/.local   ; OPT_USER=true ; OPT_DEVELOP=true ; shift 1 ;;
        --prefix)     PREFIX=$2                          ; shift 2 ;;

        -c|--clean) OPT_CLEAN=true  ; shift ;;
        --no-clean) OPT_CLEAN=false ; shift ;;

        --) shift ; break ;;
        *) echo "Internal error!" >&2 ; exit 1 ;;

    esac
done
if [[ "$#" != 0 ]] ; then
    echo "Extraneous arguments: $*" >&2
    exit 1
fi

if $OPT_HELP ; then
    echo "Usage: $0 [options...]"
    echo "Options:"
    echo "  -h, --help          Print this help and exit"
    echo "  -y, --yes           Answer yes to all prompts (unattended)"
    echo
    echo "  -i, --install       Install (default)"
    echo "  -r, --reinstall     Reinstall even if already installed"
    echo "  -u, --uninstall     Uninstall instead of installing"
    echo
    echo "  -U, --user          Select user installation target (~/.local)"
    echo "  -S, --system        Select system installation target (/usr/local)"
    echo "  -D, --develop       Select development installation target (~/.local)"
    echo "  --prefix PREFIX     Specify custom installation prefix (or PREFIX environment variable)"
    echo
    echo "  -c, --clean         Clean build artifacts after installing/uninstalling (use less space)"
    echo "  --no-clean          Do not clean build artifacts (faster re-builds) (default)"
    exit 0
fi

if [[ -z "$PREFIX" ]] ; then
    echo "Please specify installation target (e.g.: --user, --system)" >&2
    exit 1
fi

if ! [[ -d "$PREFIX" ]] ; then
    $(PREFIX_SUDO) mkdir "$PREFIX"
fi

PREFIX_SUDO=$([[ -w "$PREFIX" ]] || echo sudo)
maybe_sudo=$([[ "$USER" = "root" ]] || echo sudo)

lsb_codename=
if [[ -z "$lsb_codename" ]] && type -P lsb_release > /dev/null ; then
    lsb_codename=$(lsb_release -cs 2>/dev/null)
fi
if [[ -z "$lsb_codename" ]] && [[ -f /etc/os-release ]] ; then
    lsb_codename=$(sed -n -e 's/^BUILD_ID=//p' /etc/os-release)
fi
lsb_codename=${lsb_codename:-unknown}
UNAME_S=$(uname -s || true)

print_h2() {
    echo
    echo
    echo "## $*"
    echo
}

test_prog_installed() {
    local prog=$1 ; shift
    local v

    echo -n "$prog installed? "
    v=$(which "$prog" 2> /dev/null || true)
    if [[ -n "$v" ]] ; then
        echo "Yes: $v"
    else
        echo "No"
        echo "Error: $prog not found!" >&2
        return 1
    fi
}

if [[ -e /etc/debian_version ]] ; then
    PMS=apt-get
    DISTRO=debian

    test_package_installed() {
        local package=$1 ; shift
        local v

        echo -n "$package package installed? "
        v=$(dpkg -s "$package" 2> /dev/null | sed -n -e 's/^Version: //p' | head -n1 || true)
        if [[ -n "$v" ]] ; then
            echo "Yes: $v"
        else
            echo "No"
            echo "Error: $package package not found!" >&2
            return 1
        fi
    }

    install_package() {
        local package=$1 ; shift
        local ask=true
        local v=
        while [[ "$#" != 0 ]] ; do
            case "$1" in
                -y) ask=false ;;
                *) echo "Invalid argument: $1" >&2 ; exit 1 ;;
            esac
        done

        set -- apt-get install $($OPT_YES && echo -y) $package
        [[ "$USER" = "root" ]] || set -- $maybe_sudo "$@"

        if ! $ask || ask_yes_no "Install $package package ($*)?" ; then
            (set -x && "$@") || exit 1
        else
            return 1
        fi
    }

elif [[ -e /etc/arch-release ]] ; then
    PMS=pacman
    DISTRO=arch

    test_package_installed() {
        local package=$1 ; shift
        local v

        echo -n "$package package installed? "
        if v=$(pacman -Q "$package" 2> /dev/null) && [[ -n "$v" ]] ; then
            echo "Yes: $v"
        else
            echo "No"
            echo "Error: $package package not found!" >&2
            return 1
        fi
    }

    install_package() {
        local package=$1 ; shift
        local ask=true
        local v=
        while [[ "$#" != 0 ]] ; do
            case "$1" in
                -y) ask=false ;;
                *) echo "Invalid argument: $1" >&2 ; exit 1 ;;
            esac
        done

        set -- pacman $($OPT_YES && echo --noconfirm) -S $package
        [[ "$USER" = "root" ]] || set -- $maybe_sudo "$@"

        if ! $ask || ask_yes_no "Install $package package ($*)?" ; then
            (set -x && "$@") || exit 1
        else
            return 1
        fi
    }

    install_aur_package() {
        local package=$1 ; shift
        local package_file=
        local ask=true
        local v=
        while [[ "$#" != 0 ]] ; do
            case "$1" in
                -y) ask=false ;;
                *) echo "Invalid argument: $1" >&2 ; exit 1 ;;
            esac
        done

        if ! $ask || ask_yes_no "Build & install $package package from AUR?" ; then

            (set -x && git clone "https://aur.archlinux.org/$package.git" "$MY_TMPDIR/$package") || exit 1
            (set -x && cd "$MY_TMPDIR/$package" ; makepkg) || exit 1
            package_file=$(find "%MY_TMPDIR/$package" -name "$package-*.pkg.tar.zst")
            if [[ -z "$package_file" ]] ; then
                echo "Failed to build package $package" >&2
                return 1
            fi

            set -- pacman $($OPT_YES && echo --noconfirm) -U "$package_file"
            [[ "$USER" = "root" ]] || set -- $maybe_sudo "$@"

            (set -x && "$@") || exit 1
        else
            return 1
        fi
    }

elif [[ "$UNAME_S" = 'Darwin' ]] ; then
    PMS=brew
    DISTRO=darwin

    PATH="${PATH}:/Applications/MakeMKV.app/Contents/MacOS"

    # qip-media-tools is not signed by Apple, you might need to adjust gatekeeper options in order to install the program:
    #     https://support.apple.com/en-us/HT202491

    test_package_installed_pkgutil() {
        local package=$1 ; shift
        local v

        echo -n "$package package installed? "
        if v=$(pkgutil --pkgs="$package" 2> /dev/null) && [[ -n "$v" ]] ; then
            echo "Yes: $v"
        else
            echo "No"
            echo "Error: $package package not found!" >&2
            return 1
        fi
    }

    test_package_installed_brew() {
        local package=$1 ; shift
        local v

        echo -n "$package package installed? "
        if v=$(brew list --versions "$package" 2> /dev/null) && [[ -n "$v" ]] ; then
            echo "Yes: $v"
        else
            echo "No"
            echo "Error: $package package not found!" >&2
            return 1
        fi
    }

    test_package_installed() {
        test_package_installed_brew "$@"
    }

    install_package_brew() {
        local package=$1 ; shift
        local ask=true
        local v=
        while [[ "$#" != 0 ]] ; do
            case "$1" in
                -y) ask=false ;;
                *) echo "Invalid argument: $1" >&2 ; exit 1 ;;
            esac
        done

        set -- brew install $package
        if ! $OPT_USER ; then
            [[ "$USER" = "root" ]] || set -- $maybe_sudo "$@"
        fi

        if ! $ask || ask_yes_no "Install $package package ($*)?" ; then
            (set -x && "$@") || exit 1
        else
            return 1
        fi
    }

    install_package() {
        install_package_brew "$@"
    }

else
    echo "ERROR: Unknown package management system." >&2
    echo "Sorry, your system is not supported at this time." >&2
    exit 1
fi

# osInfo[/etc/redhat-release]=yum
# osInfo[/etc/arch-release]=pacman
# osInfo[/etc/gentoo-release]=emerge
# osInfo[/etc/SuSE-release]=zypp
# osInfo[/etc/debian_version]=apt-get

test_docker_image_installed() {
    local image=$1 ; shift
    local v=

    echo -n "Docker $image image installed? "
    v=$(docker image ls -q "$image")
    if [[ -n "$v" ]] ; then
        echo " Yes"
    else
        echo " No"
        echo "Error: docker $image not found!" >&2
        return 1
    fi
}

test_python_module_installed() {
    local module=$1 ; shift
    local v=

    echo -n "Python module $module installed? "
    # v=$($PYTHON -c "import importlib ; print(importlib.util.find_spec('${module}') is not None)" 2> /dev/null)
    v=$($PYTHON -c "import ${module} ; print(True)" 2> /dev/null)
    if [[ "$v" = "True" ]] ; then
        echo " Yes"
    else
        echo " No"
        echo "Error: Python module $module not found!" >&2
        return 1
    fi
}

_has_docker=
need_docker() {
    if [[ -z "$_has_docker" ]] ; then
        if test_prog_installed docker ; then
            _has_docker=true
        else
            _has_docker=false
            print_h2 "Docker"
            echo "Docker is a container framework that reduces complexity of porting"
            echo "applications. Several 3rd-party applications used by qualIP's Media Tools"
            echo "are made available in dockers."
            echo
            echo "See https://www.docker.com"
            echo

            case "$DISTRO-$lsb_codename" in
                *-bullseye|*-buster)
                    echo "Following Docker install instructions for Debian $lsb_codename:"
                    echo "    https://docs.docker.com/engine/install/debian/"
                    echo
                    $maybe_sudo apt-get install $($OPT_YES && echo -y) apt-transport-https ca-certificates curl gnupg lsb-release
                    curl -fsSL https://download.docker.com/linux/debian/gpg \
                        | $maybe_sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg
                    echo "deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/debian $(lsb_release -cs) stable" \
                        | $maybe_sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
                    $maybe_sudo apt-get update
                    ;;

                *-hirsute|*-groovy|*-focal|*-bionic|*-xental)
                    echo "Following Docker install instructions for Ubuntu $lsb_codename:"
                    echo "    https://docs.docker.com/engine/install/ubuntu/"
                    echo
                    $maybe_sudo apt-get install $($OPT_YES && echo -y) apt-transport-https ca-certificates curl gnupg lsb-release
                    curl -fsSL https://download.docker.com/linux/ubuntu/gpg \
                        | $maybe_sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg
                    echo "deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable" \
                        | $maybe_sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
                    $maybe_sudo apt-get update
                    ;;

                arch-*)
                    # Rolling release; Expect latest.
                    echo "Following Docker install instructions for Arch $lsb_codename:"
                    echo "    https://wiki.archlinux.org/title/docker"
                    echo
                    $maybe_sudo pacman $($OPT_YES && echo --noconfirm) -S docker
                    ;;

                darwin-*)
                    echo "Please follow the Docker Desktop installation instructions for Mac OS X:"
                    echo "    https://docs.docker.com/docker-for-mac/install/"
                    echo
                    echo "Don't forget to run the application once to complete the installation."
                    echo "Please fix the issue and run $0 again."
                    exit 1
                    ;;

                *)
                    echo "No special instructions known for $DISTRO release codename '$lsb_codename'"
                    echo
                    ;;
            esac

            case "$DISTRO" in
                debian|ubuntu)
                    package_name=docker-ce
                    ;;
                *)
                    package_name=docker
                    ;;
            esac
            install_package $package_name

            if test_prog_installed docker ; then
                _has_docker=true
            else
                echo "docker (installed by $package_name package) is not found!" >&2
                exit 1
            fi
        fi
        if $_has_docker ; then
            if ! (set -x && docker info) ; then
                echo
                echo "You don't seem to be able to run docker commands."
                echo "Try:"
                echo
                echo "    docker info"
                if type -P systemctl > /dev/null ; then
                    echo
                    ( (set -x && systemctl status docker) | cat ) || true
                    echo
                    echo "If the docker service is not active, you may need to enable and start it:"
                    echo
                    echo "    sudo systemctl enable docker"
                    echo "    sudo systemctl start docker"
                fi
                if groups | grep -qw docker ; then
                    : #echo ; echo "You are part of the docker group."
                else
                    echo
                    echo "You are not part of the docker group. You probably need to run the"
                    echo "following command to be added to the group:"
                    echo
                    echo "    sudo gpasswd -a $USER docker"
                    echo
                    echo "Once done, please start a new login session (or reboot) for the change to"
                    echo "be effective."
                    echo
                fi
                echo "Please fix the issue and run $0 again."
                exit 1
            fi
        fi
    fi
    $_has_docker
}

_has_docker_wine=
need_docker_wine() {
    if [[ -z "$_has_docker_wine" ]] ; then
        if $OPT_INSTALL ; then
            if test_docker_image_installed qualIP/wine64 \
                    && test_docker_image_installed qualIP/wine32 \
                ; then
                _has_docker_wine=true
            else
                _has_docker_wine=false
            fi
        else
            if test_docker_image_installed qualIP/wine64 \
                    || test_docker_image_installed qualIP/wine32 \
                ; then
                _has_docker_wine=true
            else
                _has_docker_wine=false
            fi
        fi
        if $OPT_INSTALL ; then
            if $OPT_REINSTALL || ! $_has_docker_wine ; then
                print_h2 "Wine"
                echo "Wine is a Windows compatibility layer for Linux which allows running some"
                echo "3rd-party Windows applications used by qualIP's Media Tools."
                echo "Dockers for wine32 and wine64 are used as standard base for these"
                echo "3rd-party Windows applications."
                echo
                echo "See https://www.docker.com"
                echo
                if ask_yes_no "Build and install wine dockers?" \
                        && need_docker \
                    ; then
                    (set -x && $MAKE -C docker/wine) || exit $?
                    (set -x && $MAKE -C docker/wine tag-latest) || exit $?
                    $OPT_CLEAN && (set -x && $MAKE -C docker/wine clean)
                    _has_docker_wine=true
                fi
            fi
        else
            if $_has_docker_wine \
                    && ask_yes_no "Uninstall wine dockers?" \
                ; then
                (set -x && $MAKE -C docker/wine PREFIX="$PREFIX" uninstall)
                $OPT_CLEAN && (set -x && $MAKE -C docker/wine clean)
                _has_docker_wine=false
            fi
        fi
    fi
    $_has_docker_wine
}

ask_yes_no() {
    local q=$1 ; shift
    local v=

    while true ; do
        echo -n "$q [Y/n] "
        if $OPT_YES ; then
            v=yes
            echo "$v"
        else
            read v
        fi
        case "x$v" in
            x|xY|xy|xyes) v=true ; break ;;
            xN|xn|xno) v=false ; break ;;
            *) echo "Invalid input! Please try again" ;;
        esac
    done
    $v
}


#print_h2 "Prologue"
echo
echo "This program will help you install qualIP's Media Tools and its"
echo "dependencies."
echo "Sudo access will be required to install certain tools."

print_h2 "System Information"
echo "Installation mode: $( \
    $OPT_REINSTALL && echo "Reinstall" || \
    ($OPT_INSTALL && echo "Install" || \
     echo "Uninstall"))"
echo "Installation target: $( \
    $OPT_DEVELOP && echo "Development" || \
    ($OPT_USER && echo "User" || \
     echo "System"))"
echo "Installation prefix: $PREFIX"
echo "Prompt mode: $($OPT_YES && echo "Answer yes" || echo "Prompt")"
echo "Clean mode: $($OPT_CLEAN && echo "Clean" || echo "No clean")"
echo "LSB release codename: $lsb_codename"

echo
echo "Run "'`'"$0 --help"'`'" for more options."

echo
ask_yes_no "Ready to proceed?"


print_h2 "Package dependencies"
echo "qualIP's Media Tools require several 3rd-party application packages"
echo "available in most Linux distributions."
echo "A small dependency-only package, \"qip-media-tools-depends\" is used to"
echo "make sure all required applications are installed."
echo
if $OPT_INSTALL ; then
    if $OPT_REINSTALL || ! test_package_installed qip-media-tools-depends ; then
        if ask_yes_no "Install qip-media-tools-depends package?" ; then

            if [[ "$PMS" = "pacman" ]] && [[ "$DISTRO" = "arch" ]] ; then
                if $OPT_REINSTALL || ! test_package_installed libudfread-git ; then
                    install_aur_package libudfread-git
                fi
            fi

            (set -x && $MAKE -C src install-qip-media-tools-depends)

        fi
        if ! test_package_installed qip-media-tools-depends ; then
            echo
            echo "The qip-media-tools-depends package failed to install."
            case "$DISTRO-$lsb_codename" in
                *-buster)
                    echo
                    echo "Debian buster may require extra preparations."
                    echo
                    echo "Extra contrib and non-free package sources:"
                    echo
                    echo "    sudo sed -i -e 's/ main *$/ main contrib non-free/' /etc/apt/sources.list"
                    echo "    sudo apt-get update"
                    echo
                    echo "libudfread-dev is not available in Debian $lsb_codename, add backports:"
                    echo
                    echo "    echo deb http://deb.debian.org/debian/ buster-backports main contrib non-free | sudo tee /etc/apt/sources.list.d/buster-backports.list"
                    echo "    sudo apt-get update"
                    echo
                    echo "Please fix the issue and run $0 again."
                    exit 1
                    ;;

                *-focal)
                    echo
                    echo "Ubuntu $lsb_codename may require extra preparations."
                    echo
                    echo "libudfread-dev is not available in Ubuntu $lsb_codename, get it from groovy:"
                    echo
                    echo "    wget http://mirrors.kernel.org/ubuntu/pool/universe/libu/libudfread/libudfread-dev_1.1.0-1_amd64.deb"
                    echo "    wget http://mirrors.kernel.org/ubuntu/pool/universe/libu/libudfread/libudfread0_1.1.0-1_amd64.deb"
                    echo "    sudo dpkg -i libudfread-dev_1.1.0-1_amd64.deb libudfread0_1.1.0-1_amd64.deb"
                    echo
                    echo "Please fix the issue and run $0 again."
                    exit 1
                    ;;

                *)
                    echo
                    echo "Sorry, there are no special instructions at this time for $DISTRO"
                    echo "release codename '$lsb_codename'"
                    echo
                    exit 1
                    ;;
            esac
        fi
    fi
else
    if test_package_installed qip-media-tools-depends \
            && ask_yes_no "Uninstall qip-media-tools-depends package?" \
        ; then
        (set -x && $MAKE -C src uninstall-qip-media-tools-depends)
    fi
fi


print_h2 "PyAV (qualIP fork)"
echo "PyAV is a Pythonic binding for the FFmpeg libraries."
echo "The qualIP/PyAV fork has many enhancements required."
echo
#echo "See https://github.com/PyAV-Org/PyAV"
echo "See https://github.com/qualIP/PyAV"
echo

src_pyav_dir="$(pwd)/src/qip/PyAV"
if $OPT_INSTALL ; then
    if $OPT_REINSTALL || ! test_python_module_installed av ; then
        if ask_yes_no "Build and install Python module av (qualIP/PyAV)?" \
            ; then
            if ! [[ -d "$src_pyav_dir" ]] ; then
                (set -x && git clone "https://github.com/qualIP/PyAV.git" "$src_pyav_dir")
            fi
            (set -x ; cd "$src_pyav_dir" ; $PYTHON setup.py build)
            if $OPT_DEVELOP ; then
                (set -x ; cd "$src_pyav_dir" ; $PYTHON setup.py develop --user)
            elif $OPT_USER ; then
                (set -x ; cd "$src_pyav_dir" ; $PIP install . --user)
            else
                (set -x ; cd "$src_pyav_dir" ; $PREFIX_SUDO $PIP install .)
            fi
            test_python_module_installed av
        fi
    fi
else
    if (test_python_module_installed av \
        ) \
            && ask_yes_no "Uninstall Python module av (qualIP/PyAV)?" \
        ; then
        if $OPT_USER ; then
            (set -x ; $PIP uninstall "av")
        else
            (set -x ; $PREFIX_SUDO $PIP uninstall "av")
        fi
        $OPT_CLEAN && (set -x && $MAKE -C "$src_pyav_dir" clean)
    fi
fi

print_h2 "qaac"
echo "qaac is a CLI QuickTime AAC/ALAC encoder."
echo "It is required to encode audio files (music, audiobooks) in .m4a format"
echo "using Apple/iTunes's own AAC encoder resulting in widely compatible"
echo "high-quality compressed audio files."
echo
echo "See https://github.com/nu774/qaac"
echo

if $OPT_INSTALL ; then
    if $OPT_REINSTALL || ! test_prog_installed qaac ; then
        if ask_yes_no "Build and install qaac docker?" \
                && need_docker \
                && need_docker_wine \
            ; then
            (set -x && $MAKE -C docker/qaac)
            (set -x && $MAKE -C docker/qaac tag-latest)
            (set -x && $MAKE -C docker/qaac PREFIX="$PREFIX" install)
            $OPT_CLEAN && (set -x && $MAKE -C docker/qaac clean)
        fi
    fi
else
    if (test_prog_installed qaac \
            || test_docker_image_installed qualIP/qaac \
        ) \
            && ask_yes_no "Uninstall qaac docker?" \
        ; then
        (set -x && $MAKE -C docker/qaac PREFIX="$PREFIX" uninstall)
        $OPT_CLEAN && (set -x && $MAKE -C docker/qaac clean)
    fi
fi


print_h2 "SubtitleEdit"
echo "Subtitle Edit is an editor for video subtitles"
echo "It is required to view subtitles and convert them between different"
echo "formats, including using character recognition (OCR) to convert video"
echo "subtitles, often found in DVD and Blu-ray movies, into text subtitles."
echo
echo "See https://nikse.dk/SubtitleEdit/"
echo

if $OPT_INSTALL ; then
    if $OPT_REINSTALL || ! test_prog_installed SubtitleEdit ; then
        if ask_yes_no "Build and install SubtitleEdit docker?" \
                && need_docker \
                && need_docker_wine \
            ; then
            (set -x && $MAKE -C docker/SubtitleEdit)
            (set -x && $MAKE -C docker/SubtitleEdit tag-latest)
            (set -x && $MAKE -C docker/SubtitleEdit PREFIX="$PREFIX" install)
            $OPT_CLEAN && (set -x && $MAKE -C docker/SubtitleEdit clean)
        fi
    fi
else
    if (test_prog_installed SubtitleEdit \
            || test_docker_image_installed qualIP/subtitleedit \
        ) \
            && ask_yes_no "Uninstall SubtitleEdit docker?" \
        ; then
        (set -x && $MAKE -C docker/SubtitleEdit PREFIX="$PREFIX" uninstall)
        $OPT_CLEAN && (set -x && $MAKE -C docker/SubtitleEdit clean)
    fi
fi


print_h2 "FRIMDecode"
echo "FRIMDecode is a 3D-MVC Decoder."
echo "It is required to decode 3D movies that are encoded in Multiview Video"
echo "Coding format. For example, 3D Blu-ray movies."
echo
echo "See https://www.videohelp.com/software/FRIM"
echo

if $OPT_INSTALL ; then
    if $OPT_REINSTALL || ! test_prog_installed FRIMDecode ; then
        if ask_yes_no "Build and install FRIM docker?" \
                && need_docker \
                && need_docker_wine \
            ; then
            (set -x && $MAKE -C docker/frim)
            (set -x && $MAKE -C docker/frim tag-latest)
            (set -x && $MAKE -C docker/frim PREFIX="$PREFIX" install)
            $OPT_CLEAN && (set -x && $MAKE -C docker/frim clean)
        fi
    fi
else
    if (test_prog_installed FRIMDecode \
            || test_docker_image_installed qualIP/frim \
        ) \
            && ask_yes_no "Uninstall FRIM docker?" \
        ; then
        (set -x && $MAKE -C docker/frim PREFIX="$PREFIX" uninstall)
        $OPT_CLEAN && (set -x && $MAKE -C docker/frim clean)
    fi
fi


if ! $OPT_INSTALL ; then
    _has_docker_wine=
    need_docker_wine || true
fi


print_h2 "MakeMKV"
echo "MakeMKV is a format converter, otherwise called \"transcoder\" that can"
echo "extract video/audio tracks from DVD and Blu-ray discs you own."
echo "qualIP's Media Tools uses the console version of MakeMKV, makemkvcon."
echo
echo "NOTE: You must have a paid license key or a valid Linux Beta key:"
echo "      https://www.makemkv.com/forum/viewtopic.php?t=1053"
echo
echo "See https://www.makemkv.com/"
echo

if $OPT_INSTALL ; then
    if $OPT_REINSTALL || ! test_prog_installed makemkvcon ; then
        if ask_yes_no "Build and install MakeMKV?" ; then
            (set -x && PREFIX="$PREFIX" installs/install-makemkv latest)
        fi
    fi
else
    if test_prog_installed makemkvcon \
            && ask_yes_no "Uninstall MakeMKV?" \
        ; then
        (set -x && PREFIX="$PREFIX" installs/uninstall-makemkv)
    fi
fi


print_h2 "qualIP's Media Tools"

if $OPT_INSTALL ; then
    if ask_yes_no "Install qualIP's Media Tools?" ; then
        if $OPT_DEVELOP ; then
            (set -x && $MAKE -C src develop)
        elif $OPT_USER ; then
            (set -x && $MAKE -C src install-user)
        else
            (set -x && $MAKE -C src install-system)
        fi
    fi
else
    if ask_yes_no "Uninstall qualIP's Media Tools?" ; then
        if $OPT_USER ; then
            (set -x && $MAKE -C src uninstall-user)
        else
            (set -x && $MAKE -C src uninstall-system)
        fi
    fi
fi


echo
echo "All done. Enjoy!"
echo
